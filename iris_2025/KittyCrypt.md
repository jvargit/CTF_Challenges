# KittyCrypt - crypto 

## Challenge

Provided example plaintext & respective ciphertext:

`'You fools! You will never get my catnip!!!!!!!'`

🐱‍💻😸😿😼🐱‍👓😺😾😿🙀🐱‍💻🐱‍👓😺😿😹😿🐱‍💻🐱‍👓🐱🐱‍👤😹😿😺🐱‍👓😹🙀😿😾🐱‍🏍🐱‍👓😹😾🐱‍🚀🐱‍👤😾🐱‍💻🐱‍👓😿😽🐱‍👓😺😾🐱‍👤🙀😻🐱‍👓😸🙀😼🐱‍👤🐈🐱‍👓😺🐱‍👤😼😿😾🐱‍👓🐈😿😽🙀🐱‍🚀🐱‍👓😹😾😹🐱‍👤🐱‍👤🐱‍👓😹🙀🐱🐱‍👤😾🐱‍👓🐱🙀😽😿😻🐱‍👓😹🐱‍👤🐱🐱‍👤🐱‍👤🐱‍👓🐈😾😽😿🐱‍💻🐱‍👓🐈🙀🐱‍👓😿🐱‍👤🐱‍👓😹🐱‍👤🐱‍👤😾🐱‍🏍🐱‍👓🐈🐱‍👤🐱😿🐱‍👤🐱‍👓😸😾😿🐱‍👤😾🐱‍💻🐱‍🏍😿🙀🐱‍👓😸😾🙀🙀🐱🐱‍👓😸🐱‍👤🐱‍👓🙀🐱‍👓🐱‍👓🐱🙀🙀😾😺🐱‍👓😺🙀😽😿😸🐱‍👓😸🐱‍👤😾🙀🐈🐱‍👓😺🙀😼🙀😼🐱‍👓😺😿😿😿😿🐱‍🏍😿😾🐱‍👓🐱‍👓😺😿😽😿🐱‍🏍🐱‍👓🐈😾🐈😿😹🐱‍💻😸🐱‍👤😹🐱‍👓😺😿🐱‍👓🙀🐱🐱‍👓😺🙀🐱‍👤😾🐱‍🏍🐱‍👓😹🐱‍👤😸🙀🐱‍🏍🐱‍👓😹🐱‍👤😼🐱‍👤😾🐱‍👓🐱🙀🐈🐱‍👤🐈🐱‍👓😺😿🐱‍👤🐱‍👤😽🐱‍👓😸🐱‍👤🐈🐱‍👤🐱‍🚀🐱‍👓😺🐱‍👤😽🙀😿🐱‍👓😺😿🐱‍💻🙀😿🐱‍👓😺😾🐱‍👤😿🐱‍🚀🐱‍👓😸🙀🐱‍🏍🐱‍👤😻🐱‍👓😸🐱‍👤🐱‍💻🐱‍👤😾🐱‍👓😹😿😻🙀🐱‍🚀🐱‍👓😹😿😿😿😿

As well as unknown ciphertext:

🐱‍💻😸🙀😼🐱‍👓😺😾😿🐱‍👤🐱🐱‍👓😺😿😹😿🐈🐱‍👓🐱🐱‍👤😺🙀😽🐱‍👓😹🙀😿😾😿🐱‍👓😹😾🐱‍🚀🐱‍👤🐱‍💻🐱‍💻🐱‍👓😾🐱‍👓🐱‍👓😺😾🐱‍👤🐱‍👤😺🐱‍👓😸🙀😼🐱‍👤🐈🐱‍👓😺🐱‍👤😼🙀😽🐱‍👓🐈😿😾🐱‍👤🐱‍🏍🐱‍👓😹😾😹😿😻🐱‍👓😹🙀🐱😾🐱🐱‍👓🐱🙀😼😿🐈🐱‍👓😹🐱‍👤😸😾😾🐱‍👓🐈😾😼😿😿🐱‍👓🐈🙀🐱‍👓🙀😻🐱‍👓😹🐱‍👤🙀🐱‍👤🐱‍🚀🐱‍👓🐈🐱‍👤🐱😿🐈🐱‍👓😸😾🙀🐱‍👤🐈🐱‍💻🐱‍👤🙀😹🐱‍👓😸😾😿🙀🐱‍👓🐱‍👓😸🐱‍👤🐱‍💻🙀🐱‍💻🐱‍👓🐱🙀😿🐱‍👤🐱‍👓🐱‍👓😺🙀😼😿😺🐱‍👓😸🐱‍👤😿🐱‍👤😹🐱‍👓😺🙀😻🐱‍👤😸🐱‍👓😺😿😿🙀😸🐱‍🏍😾😿🐈🐱‍👓😺😿😾😿🐱‍👤🐱‍👓🐈😾🐈😿🐱‍💻🐱‍💻😸🙀😸🐱‍👓😺😿🐱‍👓🐱‍👤😺🐱‍👓😺🙀🙀🙀🐱🐱‍👓😹🐱‍👤😸🙀🙀🐱‍👓😹🐱‍👤😼🐱‍👤🐱‍💻🐱‍👓🐱🙀🐱🐱‍👤😹🐱‍👓😺😿🐱‍🏍😾😹🐱‍👓😸🐱‍👤🐈🙀🐱‍👓🐱‍👓😺🐱‍👤😽🐱‍👤🐱‍👤🐱‍👓😺😿🐱‍🚀😾🐱🐱‍👓😺😾🐱‍🏍🙀🐱‍👓🐱‍👓😸🙀🐱‍💻😾😽🐱‍👓😸🐱‍👤🐱‍👓🐱‍👤🙀🐱‍👓😹😿😼😾😻🐱‍👓😹😿🙀🐱‍👤😻

Provided Go encryption algorithm.

## Solve

To begin with, we can see how the program encodes hex values to a 'catified' representation:

```go
var CharSet = map[rune]string{
	'0': "🐱", '1': "🐈", '2': "😸", '3': "😹",
	'4': "😺", '5': "😻", '6': "😼", '7': "😽",
	'8': "😾", '9': "😿", 'A': "🙀", 'B': "🐱‍👤",
	'C': "🐱‍🏍", 'D': "🐱‍💻", 'E': "🐱‍👓", 'F': "🐱‍🚀",
}
```
> - Creates variable `CharSet` which is a map (key-value data structure similar to a dictionary in Python)
> - The keys are `runes` - Go representation of Unicode characters - kind of like applying Python `ord()`
> - The values are `strings` (cat emojis)
> - Each hexadecimal digit is replaced with one or two cat emojis

This was my first time reading Go which made the challenge significantly more difficult. If we look at the `catify()` function we can see the encryption algorithm and exactly when `CharSet` is applied to transform hex digits into cats:

```go
func catify(input string, keys []int) string {
	var keyedText string
	var result string

	for i, char := range input {
		keyedText += string(rune(int(char) + keys[i]))
	}
	fmt.Printf("I2Keyed: %s\n", keyedText)

	hexEncoded := strings.ToUpper(hex.EncodeToString([]byte(keyedText)))
	fmt.Printf("K2Hex: %s\n", hexEncoded)

	for _, rune := range hexEncoded {
		result += CharSet[rune]
	}

	return result
}
```
> `for i, char := range input {...}`
- Loops through each character in the string input, adds the Unicode value and key value together and converts a string, then appends to `keyedText`
> `hexEncoded := strings.ToUpper(hex.EncodeToString([]byte(keyedText)))`
- Converts `keyedText` to an upper case hex encoded string
> `for _, rune := range hexEncoded{...}`
- Once keys have been applied to the input text and it has been hex encoded, iterate through each hex digit and apply cat subsitution alphabet

So, to decrypt this ciphertext, we need to reverse these steps:

**1. Convert cat digits back to hex string**

**2. Decode hex string back to keyed text**

**3. Reverse key operation (by subtracting key values from Unicode code point values) to obtain plaintext**


### Convert cat digits back to hex string

Thanks to LLM for writing the dictionary to reverse the emojis:

```py
char_set_reverse = {
    "🐱": '0', "🐈": '1', "😸": '2', "😹": '3',
    "😺": '4', "😻": '5', "😼": '6', "😽": '7',
    "😾": '8', "😿": '9', "🙀": 'A', "🐱‍👤": 'B',
    "🐱‍🏍": 'C', "🐱‍💻": 'D', "🐱‍👓": 'E', "🐱‍🚀": 'F'
}
```

Then we can apply the dictionary to decode the 'catified' string:

```py
def decode_cats_to_digits(cat_string):
    decoded = []

    i = 0
    while i < len(cat_string):
        if cat_string[i:i+3] in char_set_reverse:
            decoded.append(char_set_reverse[cat_string[i:i+3]])
            i += 3 
        else:
            decoded.append(char_set_reverse[cat_string[i]])
            i += 1

    return ''.join(decoded)
```

- The function iterates through the 'catified' string and converts back to hexadecimal values 
- It checks first for multi-characters which contain a length of `3`:
    - This occurs as a result of the 'Zero Width Joiner' which is a byte `\u200d` used to combine separate emoji characters into a single visual emoji. This can be viewed when splitting the cat string to an array:

    `emojis = list(cat_string)`

    ![Screenshot 2025-01-29 120310](https://github.com/user-attachments/assets/d2843657-e7dd-41af-af89-eb31b3adf39d)

- If a double character is found, the emojis are replaced by a hex digit and `i` iterates to the next unchecked character 
- The code then checks for single length characters and replaces with the respective hex digit until the end of the string is reached

### Decode hex string back to keyed text

Now that we have the hex encoded keyed text, we need to revert like so:

`keyed_text = binascii.unhexlify(hex_string).decode()`
- `unhexlify()` converts the hex string to raw binary bytes
- `.decode()` convers to text

### Reverse key operation (by subtracting key values from Unicode code point values) to obtain plaintext

Looking at `getKeys()` we can see that the program essentially generates a list of keys ranging from 0-59999 of a length equal to the length of the input:

```py
func getKeys(length int) []int {
	var keys = []int{}
	keyFileName := fmt.Sprintf("keys_%d.json", length)

	file, err := os.Open(keyFileName)
	if err != nil {

		for i := 0; i < length; i++ {
			num, _ := rand.Int(rand.Reader, big.NewInt(60000))

			keys = append(keys, int(num.Int64()))
		}

		keyFile, err := os.OpenFile(keyFileName, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
		if err != nil {
			fmt.Println(err)
			return []int{}
		}
		defer keyFile.Close()

		encoded, _ := json.Marshal(keys)
		keyFile.Write(encoded)

		return keys
	}

	json.NewDecoder(file).Decode(&keys)

	return keys
}
```

Fortunately for us, they reused the same keys as the sample input and output! I ran the existing code on the sample output to find its `keyed_text` and wrote following loop to brute force keys:

```py
found = 0
plain ='You fools! You will never get my catnip!!!!!!!'
for i in keyed_text:
    if found >= len(plain):
        break
    for j in range(0, 60000):
        if chr(ord(i) - j) == plain[found]:
            keys.append(j)
            found+=1
            break

print(keys)
```

From this I was able to obtain the keys used:

```py
keys = [1085, 16894, 17512, 3252, 14822, 13193, 1832, 17017, 10558, 19831, 5583, 12450, 14281, 2400, 15387, 4454, 6962, 15968, 7087, 8792, 1708, 8763, 12088, 2591, 18784, 11777, 18751, 17908, 474, 17852, 4070, 1082, 18304, 19049, 15435, 15684, 2051, 18062, 11279, 19912, 18248, 17086, 11028, 12119, 13646, 13880]
```
And subsequently reverse the `keyed_text` for the unknown ciphertext:

```py
def decode_catified(keys):
    plain = ""
    for i, char in enumerate(keyed_text):
        plain += chr(ord(char) - keys[i])

    return plain
```
- `enumerate` provides both the index `i` and the value at the index stored in `char`
- the key from the respective index is selected and subtracted from the Unicode value for `char` and its character representation is appended to plain

Running the function with the provided keyset presents the flag:

`irisctf{s0m371m3s_bY735_4r3n7_wh47_y0u_3xp3c7}`





















